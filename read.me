CodeVersus Project — TL;DR Snapshot
Tech Stack

Frontend: React (with React Router)

Backend: Node.js + Express

Database: PostgreSQL (local, may move to Atlas later)

Auth: JWT + bcryptjs

Package manager: pnpm

Directory Structure
codeversus/
├── apps/
│   ├── backend/
│   │   ├── src/
│   │   │   ├── controllers/
│   │   │   │   ├── authController.js
│   │   │   │   ├── lessonController.js
│   │   │   │   └── searchController.js
│   │   │   ├── routes/
│   │   │   │   ├── auth.js
│   │   │   │   ├── lessons.js
│   │   │   │   └── search.js
│   │   │   ├── middleware/
│   │   │   │   └── authMiddleware.js
│   │   │   ├── db.js
│   │   │   └── index.js
│   │   └── package.json
│   └── frontend/
│       ├── src/
│       │   ├── pages/
│       │   │   ├── LessonCreate.jsx
│       │   │   └── LessonView.jsx
│       │   ├── components/
│       │   │   ├── LessonEditor.jsx
│       │   │   ├── LessonBlock.jsx
│       │   │   └── TagInput.jsx
│       │   ├── api/
│       │   │   └── lessons.js
│       │   └── App.jsx
│       └── package.json
└── pnpm-workspace.yaml

Backend Status

✅ Auth:

Register / Login

JWT-based authentication

Password hashing via bcryptjs

✅ Lessons:

CRUD for lessons (draft/published)

Tags supported

JSON content structure (blocks)

✅ Lesson Ratings & Comments:

Ratings endpoint implemented

Comments backend skeleton in place

✅ Search:

Lesson search endpoint implemented (text + tags)

⚠️ Pending:

Final JWT handling for frontend calls (some “Invalid token” issues)

Frontend Status

✅ Lesson Creation:

Title, description, tags

Draft/publish toggle

JSON content blocks for linear editor (text, code, image)

✅ Lesson Viewing:

Shows title, description, tags, and raw JSON content

✅ Components:

LessonEditor — linear block editor

LessonBlock — individual block (text/code/image)

TagInput — add/remove tags

⚠️ Pending:

Render lesson JSON into visually formatted blocks on LessonView

Drag-and-drop block reordering (optional)

Comment/rating UI

Database

Tables:

-- Users
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(255) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Lessons
CREATE TABLE lessons (
    id SERIAL PRIMARY KEY,
    title VARCHAR(255),
    description TEXT,
    content JSONB,
    tags TEXT[],
    status VARCHAR(50),
    author_id INT REFERENCES users(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Ratings
CREATE TABLE ratings (
    id SERIAL PRIMARY KEY,
    lesson_id INT REFERENCES lessons(id),
    user_id INT REFERENCES users(id),
    rating INT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);


PostgreSQL local DB is set up

Auth user and sequences permissions fixed

Next Steps

Frontend:

Render lesson content blocks properly (LessonView)

Optional: add drag-and-drop reordering of blocks

Add comments and rating UI

Backend:

Finalize JWT auth flow for all protected endpoints

Ensure lesson update/delete only by creator

Optional: moderation tools

Deployment Prep:

Decide on hosting (Atlas + Vercel/Render)

Configure environment variables and production DB

Backend
package.json
{
  "name": "backend",
  "version": "1.0.0",
  "main": "src/index.js",
  "scripts": {
    "dev": "nodemon src/index.js"
  },
  "dependencies": {
    "express": "^4.19.0",
    "cors": "^2.8.5",
    "pg": "^8.11.0",
    "dotenv": "^16.4.0",
    "bcryptjs": "^2.4.3",
    "jsonwebtoken": "^9.0.2"
  },
  "devDependencies": {
    "nodemon": "^3.0.0"
  }
}

src/db.js
const { Pool } = require("pg");
require("dotenv").config();

const pool = new Pool({
  user: process.env.DB_USER,
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  password: process.env.DB_PASSWORD,
  port: process.env.DB_PORT
});

module.exports = pool;

src/index.js
const express = require("express");
const cors = require("cors");
require("dotenv").config();

const authRoutes = require("./routes/auth");
const lessonRoutes = require("./routes/lessons");
const searchRoutes = require("./routes/search");

const app = express();
app.use(cors());
app.use(express.json());

app.use("/auth", authRoutes);
app.use("/lessons", lessonRoutes);
app.use("/search", searchRoutes);

const PORT = process.env.PORT || 5000;
app.listen(PORT, () => console.log(`Backend running on port ${PORT}`));

src/routes/auth.js
const express = require("express");
const router = express.Router();
const authController = require("../controllers/authController");

router.post("/register", authController.register);
router.post("/login", authController.login);

module.exports = router;

src/routes/lessons.js
const express = require("express");
const router = express.Router();
const lessonController = require("../controllers/lessonController");
const authMiddleware = require("../middleware/authMiddleware");

router.post("/", authMiddleware, lessonController.createLesson);
router.get("/:id", lessonController.getLesson);
router.put("/:id", authMiddleware, lessonController.updateLesson);
router.get("/:id/ratings", lessonController.getRatings);

module.exports = router;

src/middleware/authMiddleware.js
const jwt = require("jsonwebtoken");

module.exports = function(req, res, next) {
  const authHeader = req.headers["authorization"];
  if (!authHeader) return res.status(401).json({ error: "No token" });

  const token = authHeader.split(" ")[1];
  if (!token) return res.status(401).json({ error: "No token" });

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded;
    next();
  } catch {
    return res.status(401).json({ error: "Invalid token" });
  }
};

src/controllers/authController.js
const pool = require("../db");
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");

exports.register = async (req, res) => {
  const { username, email, password } = req.body;
  try {
    const hashed = await bcrypt.hash(password, 10);
    const result = await pool.query(
      "INSERT INTO users (username, email, password) VALUES ($1,$2,$3) RETURNING id, username, email",
      [username, email, hashed]
    );
    const user = result.rows[0];
    const token = jwt.sign({ id: user.id }, process.env.JWT_SECRET, { expiresIn: "1d" });
    res.json({ success: true, user, token });
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
};

exports.login = async (req, res) => {
  const { email, password } = req.body;
  try {
    const result = await pool.query("SELECT * FROM users WHERE email=$1", [email]);
    const user = result.rows[0];
    if (!user) return res.status(400).json({ error: "Invalid credentials" });
    const match = await bcrypt.compare(password, user.password);
    if (!match) return res.status(400).json({ error: "Invalid credentials" });
    const token = jwt.sign({ id: user.id }, process.env.JWT_SECRET, { expiresIn: "1d" });
    res.json({ success: true, user: { id: user.id, username: user.username }, token });
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
};

src/controllers/lessonController.js (simplified)
const pool = require("../db");

exports.createLesson = async (req, res) => {
  const { title, description, tags, status, content } = req.body;
  try {
    const result = await pool.query(
      "INSERT INTO lessons (title, description, tags, status, content, author_id) VALUES ($1,$2,$3,$4,$5,$6) RETURNING *",
      [title, description, tags, status, content, req.user.id]
    );
    res.json({ success: true, lesson: result.rows[0] });
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
};

exports.getLesson = async (req, res) => {
  try {
    const result = await pool.query("SELECT * FROM lessons WHERE id=$1", [req.params.id]);
    if (!result.rows[0]) return res.status(404).json({ error: "Lesson not found" });
    res.json({ success: true, lesson: result.rows[0] });
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
};

exports.updateLesson = async (req, res) => {
  const { title, description, tags, status, content } = req.body;
  try {
    const result = await pool.query(
      "UPDATE lessons SET title=$1, description=$2, tags=$3, status=$4, content=$5 WHERE id=$6 AND author_id=$7 RETURNING *",
      [title, description, tags, status, content, req.params.id, req.user.id]
    );
    res.json({ success: true, lesson: result.rows[0] });
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
};

exports.getRatings = async (req, res) => {
  try {
    const result = await pool.query("SELECT rating FROM ratings WHERE lesson_id=$1", [req.params.id]);
    const ratings = result.rows.map(r => r.rating);
    const average = ratings.length ? ratings.reduce((a,b)=>a+b,0)/ratings.length : 0;
    res.json({ success: true, ratings, average });
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
};

Frontend
package.json
{
  "name": "frontend",
  "version": "1.0.0",
  "private": true,
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.17.0",
    "axios": "^1.5.0"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build"
  }
}

src/components/TagInput.jsx

(Already provided earlier — unchanged)

src/components/LessonBlock.jsx

(Linear block editor component — text/code/image blocks)

src/components/LessonEditor.jsx

(Manages array of blocks, add/delete/update — linear editor)

src/pages/LessonCreate.jsx

(Uses LessonEditor and TagInput, includes title/description/tags/status)

src/pages/LessonView.jsx

(Currently shows raw JSON — next step: render blocks properly)

src/api/lessons.js
import axios from "axios";

const BASE_URL = "http://localhost:5000";

export const createLesson = (data) => axios.post(`${BASE_URL}/lessons`, data, {
  headers: { Authorization: `Bearer ${localStorage.getItem("token")}` }
});

export const getLesson = (id) => axios.get(`${BASE_URL}/lessons/${id}`);

Notes / Next Steps

Render LessonView with proper blocks (text, code, images)

Add drag-and-drop for block reordering (optional)

Comments & rating UI

Frontend auth login/register pages

Styling / UX improvements
